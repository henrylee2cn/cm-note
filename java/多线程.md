# 线程知识积累

------
## 1.死锁
根据操作系统中的定义：死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态。
死锁的四个必要条件：
> 互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
> 请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
> 非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
> 循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

------

------
## 2.指令重排
    在Java中看似顺序的代码在JVM中，可能会出现编译器或者CPU对这些操作指令进行了重新排序；
在特定情况下，指令重排将会给我们的程序带来不确定的结果.....
>    **比如:写后读  a = 1;b = a;  写一个变量之后，再读这个位置。**
    编译器将不会对存在数据依赖性的程序指令进行重排，这里的依赖性仅仅指单线程情况下的数据依赖性；
> 多线程并发情况下，此规则将失效。
**注意:**JDK1.5之后引入的volatile可以禁止指令重排

------

------
## 3.ThreadLocal
[技术小黑屋](http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html)

------

------
## 4.守护线程
在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 
**任何一个守护线程都是整个JVM中所有非守护线程的保姆**
### 作用
> Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者.

```
    (1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
    (2) 在Daemon线程中产生的新线程也是Daemon的。 
    (3) 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。
```
### 为什么要用守护线程？
> 我们知道静态变量是ClassLoader级别的，如果Web应用程序停止，这些静态变量也会从JVM中清除。但是线程则是JVM级别的，如果你在Web应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步。
也就是说，即使你停止了Web应用，这个线程依旧是活跃的。正是因为这个很隐晦 的问题，所以很多有经验的开发者不太赞成在Web应用中私自启动线程。

------

------
## 5.ReentrantLock

------

------
## 6.Condition

------